{"version":3,"file":"immer.js","sources":["../src/common.js","../src/scope.js","../src/es5.js","../src/proxy.js","../src/patches.js","../src/immer.js","../src/index.js"],"sourcesContent":["export const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const DRAFTABLE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol.for(\"immer-draftable\")\n        : \"__$immer_draftable\"\n\nexport const DRAFT_STATE =\n    typeof Symbol !== \"undefined\" ? Symbol.for(\"immer-state\") : \"__$immer_state\"\n\nexport function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE]\n}\n\nexport function isDraftable(value) {\n    if (!value || typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    if (!proto || proto === Object.prototype) return true\n    return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\n}\n\nexport function original(value) {\n    if (value && value[DRAFT_STATE]) {\n        return value[DRAFT_STATE].base\n    }\n    // otherwise return undefined\n}\n\nexport const assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport const ownKeys =\n    typeof Reflect !== \"undefined\" && Reflect.ownKeys\n        ? Reflect.ownKeys\n        : typeof Object.getOwnPropertySymbols !== \"undefined\"\n        ? obj =>\n              Object.getOwnPropertyNames(obj).concat(\n                  Object.getOwnPropertySymbols(obj)\n              )\n        : Object.getOwnPropertyNames\n\nexport function shallowCopy(base, invokeGetters = false) {\n    if (Array.isArray(base)) return base.slice()\n    const clone = Object.create(Object.getPrototypeOf(base))\n    ownKeys(base).forEach(key => {\n        if (key === DRAFT_STATE) {\n            return // Never copy over draft state.\n        }\n        const desc = Object.getOwnPropertyDescriptor(base, key)\n        if (desc.get) {\n            if (!invokeGetters) {\n                throw new Error(\"Immer drafts cannot have computed properties\")\n            }\n            desc.value = desc.get.call(base)\n        }\n        if (desc.enumerable) {\n            clone[key] = desc.value\n        } else {\n            Object.defineProperty(clone, key, {\n                value: desc.value,\n                writable: true,\n                configurable: true\n            })\n        }\n    })\n    return clone\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i], value)\n    } else {\n        ownKeys(value).forEach(key => cb(key, value[key], value))\n    }\n}\n\nexport function isEnumerable(base, prop) {\n    return Object.getOwnPropertyDescriptor(base, prop).enumerable\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","import {DRAFT_STATE} from \"./common\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n    constructor(parent) {\n        this.drafts = []\n        this.parent = parent\n\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        this.canAutoFreeze = true\n\n        // To avoid prototype lookups:\n        this.patches = null\n    }\n    usePatches(patchListener) {\n        if (patchListener) {\n            this.patches = []\n            this.inversePatches = []\n            this.patchListener = patchListener\n        }\n    }\n    revoke() {\n        this.leave()\n        this.drafts.forEach(revoke)\n        this.drafts = null // Make draft-related methods throw.\n    }\n    leave() {\n        if (this === ImmerScope.current) {\n            ImmerScope.current = this.parent\n        }\n    }\n}\n\nImmerScope.current = null\nImmerScope.enter = function() {\n    return (this.current = new ImmerScope(this.current))\n}\n\nfunction revoke(draft) {\n    draft[DRAFT_STATE].revoke()\n}\n","\"use strict\"\nimport {\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors = {}\n\nexport function willFinalize(scope, result, isReplaced) {\n    scope.drafts.forEach(draft => {\n        draft[DRAFT_STATE].finalizing = true\n    })\n    if (!isReplaced) {\n        if (scope.patches) {\n            markChangesRecursively(scope.drafts[0])\n        }\n        // This is faster when we don't care about which attributes changed.\n        markChangesSweep(scope.drafts)\n    }\n    // When a child draft is returned, look for changes.\n    else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n        markChangesSweep(scope.drafts)\n    }\n}\n\nexport function createProxy(base, parent) {\n    const isArray = Array.isArray(base)\n    const draft = clonePotentialDraft(base)\n    each(draft, prop => {\n        proxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n    })\n\n    // See \"proxy.js\" for property documentation.\n    const scope = parent ? parent.scope : ImmerScope.current\n    const state = {\n        scope,\n        modified: false,\n        finalizing: false, // es5 only\n        finalized: false,\n        assigned: {},\n        parent,\n        base,\n        draft,\n        copy: null,\n        revoke,\n        revoked: false // es5 only\n    }\n\n    createHiddenProperty(draft, DRAFT_STATE, state)\n    scope.drafts.push(draft)\n    return draft\n}\n\nfunction revoke() {\n    this.revoked = true\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    assertUnrevoked(state)\n    const value = source(state)[prop]\n    // Drafts are only created for proxyable values that exist in the base state.\n    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(value, state))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnrevoked(state)\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base) {\n    const state = base && base[DRAFT_STATE]\n    if (state) {\n        state.finalizing = true\n        const draft = shallowCopy(state.draft, true)\n        state.finalizing = false\n        return draft\n    }\n    return shallowCopy(base)\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n    let desc = descriptors[prop]\n    if (desc) {\n        desc.enumerable = enumerable\n    } else {\n        descriptors[prop] = desc = {\n            configurable: true,\n            enumerable,\n            get() {\n                return get(this[DRAFT_STATE], prop)\n            },\n            set(value) {\n                set(this[DRAFT_STATE], prop, value)\n            }\n        }\n    }\n    Object.defineProperty(draft, prop, desc)\n}\n\nfunction assertUnrevoked(state) {\n    if (state.revoked === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(source(state))\n        )\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (let i = drafts.length - 1; i >= 0; i--) {\n        const state = drafts[i][DRAFT_STATE]\n        if (!state.modified) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[DRAFT_STATE]\n    if (!state) return\n    const {base, draft, assigned} = state\n    if (!Array.isArray(object)) {\n        // Look for added keys.\n        Object.keys(draft).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (base[key] === undefined && !has(base, key)) {\n                assigned[key] = true\n                markChanged(state)\n            } else if (!assigned[key]) {\n                // Only untouched properties trigger recursion.\n                markChangesRecursively(draft[key])\n            }\n        })\n        // Look for removed keys.\n        Object.keys(base).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (draft[key] === undefined && !has(draft, key)) {\n                assigned[key] = false\n                markChanged(state)\n            }\n        })\n    } else if (hasArrayChanges(state)) {\n        markChanged(state)\n        assigned.length = true\n        if (draft.length < base.length) {\n            for (let i = draft.length; i < base.length; i++) assigned[i] = false\n        } else {\n            for (let i = base.length; i < draft.length; i++) assigned[i] = true\n        }\n        for (let i = 0; i < draft.length; i++) {\n            // Only untouched indices trigger recursion.\n            if (assigned[i] === undefined) markChangesRecursively(draft[i])\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, draft} = state\n\n    // Search for added keys and changed keys. Start at the back, because\n    // non-numeric keys are ordered by time of definition on the object.\n    const keys = Object.keys(draft)\n    for (let i = keys.length - 1; i >= 0; i--) {\n        const key = keys[i]\n        const baseValue = base[key]\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (baseValue === undefined && !has(base, key)) {\n            return true\n        }\n        // Once a base key is deleted, future changes go undetected, because its\n        // descriptor is erased. This branch detects any missed changes.\n        else {\n            const value = draft[key]\n            const state = value && value[DRAFT_STATE]\n            if (state ? state.base !== baseValue : !is(value, baseValue)) {\n                return true\n            }\n        }\n    }\n\n    // At this point, no keys were added or changed.\n    // Compare key count to determine if keys were deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {draft} = state\n    if (draft.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","\"use strict\"\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraftable,\n    isDraft,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// Do nothing before being finalized.\nexport function willFinalize() {}\n\nexport function createProxy(base, parent) {\n    const scope = parent ? parent.scope : ImmerScope.current\n    const state = {\n        // Track which produce call this is associated with.\n        scope,\n        // True for both shallow and deep changes.\n        modified: false,\n        // Used during finalization.\n        finalized: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned: {},\n        // The parent draft state.\n        parent,\n        // The base state.\n        base,\n        // The base proxy.\n        draft: null,\n        // Any property proxies.\n        drafts: {},\n        // The base copy with any updated values.\n        copy: null,\n        // Called by the `produce` function.\n        revoke: null\n    }\n\n    const {revoke, proxy} = Array.isArray(base)\n        ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n          // although state itself is an object\n          Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n\n    state.draft = proxy\n    state.revoke = revoke\n\n    scope.drafts.push(proxy)\n    return proxy\n}\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty() {\n        throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target.base)\n    },\n    setPrototypeOf() {\n        throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n    }\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n    }\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\n// returns the object we should be reading the current value from, which is base, until some change has been made\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    if (prop === DRAFT_STATE) return state\n    let {drafts} = state\n\n    // Check for existing draft in unmodified state.\n    if (!state.modified && has(drafts, prop)) {\n        return drafts[prop]\n    }\n\n    const value = source(state)[prop]\n    if (state.finalized || !isDraftable(value)) return value\n\n    // Check for existing draft in modified state.\n    if (state.modified) {\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value !== state.base[prop]) return value\n        // Store drafts on the copy (when one exists).\n        drafts = state.copy\n    }\n\n    return (drafts[prop] = createProxy(value, state))\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        // Optimize based on value's truthiness. Truthy values are guaranteed to\n        // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n        // values may be drafts, but falsy values are never drafts.\n        const isUnchanged = value\n            ? is(state.base[prop], value) || value === state.drafts[prop]\n            : is(state.base[prop], value) && prop in state.base\n        if (isUnchanged) return true\n        markChanged(state)\n    }\n    state.assigned[prop] = true\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (state.base[prop] !== undefined || prop in state.base) {\n        state.assigned[prop] = false\n        markChanged(state)\n    }\n    if (state.copy) delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = source(state)\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (desc) {\n        desc.writable = true\n        desc.configurable = !Array.isArray(owner) || prop !== \"length\"\n    }\n    return desc\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = assign(shallowCopy(state.base), state.drafts)\n        state.drafts = null\n        if (state.parent) markChanged(state.parent)\n    }\n}\n","import {each} from \"./common\"\n\nexport function generatePatches(state, basePath, patches, inversePatches) {\n    Array.isArray(state.base)\n        ? generateArrayPatches(state, basePath, patches, inversePatches)\n        : generateObjectPatches(state, basePath, patches, inversePatches)\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n    let {base, copy, assigned} = state\n\n    // Reduce complexity by ensuring `base` is never longer.\n    if (copy.length < base.length) {\n        ;[base, copy] = [copy, base]\n        ;[patches, inversePatches] = [inversePatches, patches]\n    }\n\n    const delta = copy.length - base.length\n\n    // Find the first replaced index.\n    let start = 0\n    while (base[start] === copy[start] && start < base.length) {\n        ++start\n    }\n\n    // Find the last replaced index. Search from the end to optimize splice patches.\n    let end = base.length\n    while (end > start && base[end - 1] === copy[end + delta - 1]) {\n        --end\n    }\n\n    // Process replaced indices.\n    for (let i = start; i < end; ++i) {\n        if (assigned[i] && copy[i] !== base[i]) {\n            const path = basePath.concat([i])\n            patches.push({\n                op: \"replace\",\n                path,\n                value: copy[i]\n            })\n            inversePatches.push({\n                op: \"replace\",\n                path,\n                value: base[i]\n            })\n        }\n    }\n\n    const useRemove = end != base.length\n    const replaceCount = patches.length\n\n    // Process added indices.\n    for (let i = end + delta - 1; i >= end; --i) {\n        const path = basePath.concat([i])\n        patches[replaceCount + i - end] = {\n            op: \"add\",\n            path,\n            value: copy[i]\n        }\n        if (useRemove) {\n            inversePatches.push({\n                op: \"remove\",\n                path\n            })\n        }\n    }\n\n    // One \"replace\" patch reverses all non-splicing \"add\" patches.\n    if (!useRemove) {\n        inversePatches.push({\n            op: \"replace\",\n            path: basePath.concat([\"length\"]),\n            value: base.length\n        })\n    }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n    const {base, copy} = state\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = base[key]\n        const value = copy[key]\n        const op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\"\n        if (origValue === value && op === \"replace\") return\n        const path = basePath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                ? {op: \"add\", path, value: origValue}\n                : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                    base[key] = patch.value\n                    break\n                case \"add\":\n                    if (Array.isArray(base)) {\n                        // TODO: support \"foo/-\" paths for appending to an array\n                        base.splice(key, 0, patch.value)\n                    } else {\n                        base[key] = patch.value\n                    }\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        base.splice(key, 1)\n                    } else {\n                        delete base[key]\n                    }\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import * as legacyProxy from \"./es5\"\nimport * as modernProxy from \"./proxy\"\nimport {applyPatches, generatePatches} from \"./patches\"\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE,\n    NOTHING\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\nfunction verifyMinified() {}\n\nconst configDefaults = {\n    useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n    autoFreeze:\n        typeof process !== \"undefined\"\n            ? process.env.NODE_ENV !== \"production\"\n            : verifyMinified.name === \"verifyMinified\",\n    onAssign: null,\n    onDelete: null,\n    onCopy: null\n}\n\nexport class Immer {\n    constructor(config) {\n        assign(this, configDefaults, config)\n        this.setUseProxies(this.useProxies)\n        this.produce = this.produce.bind(this)\n    }\n    produce(base, recipe, patchListener) {\n        // curried invocation\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\n            const defaultBase = recipe\n            recipe = base\n\n            // prettier-ignore\n            return (base = defaultBase, ...args) =>\n                this.produce(base, draft => recipe.call(draft, draft, ...args))\n        }\n\n        // prettier-ignore\n        {\n            if (typeof recipe !== \"function\") {\n                throw new Error(\"The first or second argument to `produce` must be a function\")\n            }\n            if (patchListener !== undefined && typeof patchListener !== \"function\") {\n                throw new Error(\"The third argument to `produce` must be a function or undefined\")\n            }\n        }\n\n        let result\n\n        // Only plain objects, arrays, and \"immerable classes\" are drafted.\n        if (isDraftable(base)) {\n            const scope = ImmerScope.enter()\n            const proxy = this.createProxy(base)\n            let hasError = true\n            try {\n                result = recipe.call(proxy, proxy)\n                hasError = false\n            } finally {\n                // finally instead of catch + rethrow better preserves original stack\n                if (hasError) scope.revoke()\n                else scope.leave()\n            }\n            if (result instanceof Promise) {\n                return result.then(\n                    result => {\n                        scope.usePatches(patchListener)\n                        return this.processResult(result, scope)\n                    },\n                    error => {\n                        scope.revoke()\n                        throw error\n                    }\n                )\n            }\n            scope.usePatches(patchListener)\n            return this.processResult(result, scope)\n        } else {\n            result = recipe(base)\n            if (result === undefined) return base\n            return result !== NOTHING ? result : undefined\n        }\n    }\n    createDraft(base) {\n        if (!isDraftable(base)) {\n            throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\") // prettier-ignore\n        }\n        const scope = ImmerScope.enter()\n        const proxy = this.createProxy(base)\n        proxy[DRAFT_STATE].isManual = true\n        scope.leave()\n        return proxy\n    }\n    finishDraft(draft, patchListener) {\n        const state = draft && draft[DRAFT_STATE]\n        if (!state || !state.isManual) {\n            throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\") // prettier-ignore\n        }\n        if (state.finalized) {\n            throw new Error(\"The given draft is already finalized\") // prettier-ignore\n        }\n        const {scope} = state\n        scope.usePatches(patchListener)\n        return this.processResult(undefined, scope)\n    }\n    setAutoFreeze(value) {\n        this.autoFreeze = value\n    }\n    setUseProxies(value) {\n        this.useProxies = value\n        assign(this, value ? modernProxy : legacyProxy)\n    }\n    applyPatches(base, patches) {\n        // Mutate the base state when a draft is passed.\n        if (isDraft(base)) {\n            return applyPatches(base, patches)\n        }\n        // Otherwise, produce a copy of the base state.\n        return this.produce(base, draft => applyPatches(draft, patches))\n    }\n    /** @internal */\n    processResult(result, scope) {\n        const baseDraft = scope.drafts[0]\n        const isReplaced = result !== undefined && result !== baseDraft\n        this.willFinalize(scope, result, isReplaced)\n        if (isReplaced) {\n            if (baseDraft[DRAFT_STATE].modified) {\n                scope.revoke()\n                throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n            }\n            if (isDraftable(result)) {\n                // Finalize the result in case it contains (or is) a subset of the draft.\n                result = this.finalize(result, null, scope)\n            }\n            if (scope.patches) {\n                scope.patches.push({\n                    op: \"replace\",\n                    path: [],\n                    value: result\n                })\n                scope.inversePatches.push({\n                    op: \"replace\",\n                    path: [],\n                    value: baseDraft[DRAFT_STATE].base\n                })\n            }\n        } else {\n            // Finalize the base draft.\n            result = this.finalize(baseDraft, [], scope)\n        }\n        scope.revoke()\n        if (scope.patches) {\n            scope.patchListener(scope.patches, scope.inversePatches)\n        }\n        return result !== NOTHING ? result : undefined\n    }\n    /**\n     * @internal\n     * Finalize a draft, returning either the unmodified base state or a modified\n     * copy of the base state.\n     */\n    finalize(draft, path, scope) {\n        const state = draft[DRAFT_STATE]\n        if (!state) {\n            if (Object.isFrozen(draft)) return draft\n            return this.finalizeTree(draft, null, scope)\n        }\n        // Never finalize drafts owned by another scope.\n        if (state.scope !== scope) {\n            return draft\n        }\n        if (!state.modified) {\n            return state.base\n        }\n        if (!state.finalized) {\n            state.finalized = true\n            this.finalizeTree(state.draft, path, scope)\n\n            if (this.onDelete) {\n                // The `assigned` object is unreliable with ES5 drafts.\n                if (this.useProxies) {\n                    const {assigned} = state\n                    for (const prop in assigned) {\n                        if (!assigned[prop]) this.onDelete(state, prop)\n                    }\n                } else {\n                    const {base, copy} = state\n                    each(base, prop => {\n                        if (!has(copy, prop)) this.onDelete(state, prop)\n                    })\n                }\n            }\n            if (this.onCopy) {\n                this.onCopy(state)\n            }\n\n            // At this point, all descendants of `state.copy` have been finalized,\n            // so we can be sure that `scope.canAutoFreeze` is accurate.\n            if (this.autoFreeze && scope.canAutoFreeze) {\n                Object.freeze(state.copy)\n            }\n\n            if (path && scope.patches) {\n                generatePatches(\n                    state,\n                    path,\n                    scope.patches,\n                    scope.inversePatches\n                )\n            }\n        }\n        return state.copy\n    }\n    /**\n     * @internal\n     * Finalize all drafts in the given state tree.\n     */\n    finalizeTree(root, rootPath, scope) {\n        const state = root[DRAFT_STATE]\n        if (state) {\n            if (!this.useProxies) {\n                state.finalizing = true\n                state.copy = shallowCopy(state.draft, true)\n                state.finalizing = false\n            }\n            root = state.copy\n        }\n\n        const needPatches = !!rootPath && !!scope.patches\n        const finalizeProperty = (prop, value, parent) => {\n            if (value === parent) {\n                throw Error(\"Immer forbids circular references\")\n            }\n\n            // In the `finalizeTree` method, only the `root` object may be a draft.\n            const isDraftProp = !!state && parent === root\n\n            if (isDraft(value)) {\n                const path =\n                    isDraftProp && needPatches && !state.assigned[prop]\n                        ? rootPath.concat(prop)\n                        : null\n\n                // Drafts owned by `scope` are finalized here.\n                value = this.finalize(value, path, scope)\n\n                // Drafts from another scope must prevent auto-freezing.\n                if (isDraft(value)) {\n                    scope.canAutoFreeze = false\n                }\n\n                // Preserve non-enumerable properties.\n                if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n                    parent[prop] = value\n                } else {\n                    Object.defineProperty(parent, prop, {value})\n                }\n\n                // Unchanged drafts are never passed to the `onAssign` hook.\n                if (isDraftProp && value === state.base[prop]) return\n            }\n            // Unchanged draft properties are ignored.\n            else if (isDraftProp && is(value, state.base[prop])) {\n                return\n            }\n            // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n            else if (isDraftable(value) && !Object.isFrozen(value)) {\n                each(value, finalizeProperty)\n            }\n\n            if (isDraftProp && this.onAssign) {\n                this.onAssign(state, prop, value)\n            }\n        }\n\n        each(root, finalizeProperty)\n        return root\n    }\n}\n","import {Immer} from \"./immer\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce = immer.produce\nexport default produce\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\nexport {\n    original,\n    isDraft,\n    isDraftable,\n    NOTHING as nothing,\n    DRAFTABLE as immerable\n} from \"./common\"\n\nexport {Immer}\n"],"names":["NOTHING","Symbol","DRAFTABLE","for","const","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","constructor","original","base","assign","target","let","key","has","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","shallowCopy","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","ImmerScope","parent","drafts","canAutoFreeze","patches","usePatches","patchListener","inversePatches","revoke","leave","current","enter","draft","descriptors","willFinalize","scope","result","isReplaced","finalizing","markChangesRecursively","markChangesSweep","createProxy","clonePotentialDraft","proxyProperty","state","modified","finalized","assigned","copy","revoked","createHiddenProperty","push","source","assertUnrevoked","prepareCopy","set","markChanged","JSON","stringify","hasArrayChanges","hasObjectChanges","object","keys","undefined","baseValue","descriptor","Proxy","revocable","arrayTraps","objectTraps","proxy","deleteProperty","setPrototypeOf","fn","arguments","apply","isNaN","parseInt","isUnchanged","owner","generatePatches","basePath","generateArrayPatches","generateObjectPatches","delta","start","end","path","op","useRemove","replaceCount","assignedValue","origValue","applyPatches","patch","join","splice","verifyMinified","configDefaults","useProxies","autoFreeze","process","env","NODE_ENV","name","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","recipe","defaultBase","this","args","hasError","Promise","then","processResult","error","createDraft","isManual","finishDraft","setAutoFreeze","modernProxy","legacyProxy","baseDraft","finalize","isFrozen","finalizeTree","freeze","root","rootPath","needPatches","finalizeProperty","isDraftProp","immer"],"mappings":"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"}