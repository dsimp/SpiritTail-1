{"version":3,"file":"immer.umd.js","sources":["../src/common.js","../src/scope.js","../src/es5.js","../src/proxy.js","../src/patches.js","../src/immer.js","../src/index.js"],"sourcesContent":["export const NOTHING =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-nothing\")\n        : {[\"immer-nothing\"]: true}\n\nexport const DRAFTABLE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol.for(\"immer-draftable\")\n        : \"__$immer_draftable\"\n\nexport const DRAFT_STATE =\n    typeof Symbol !== \"undefined\" ? Symbol.for(\"immer-state\") : \"__$immer_state\"\n\nexport function isDraft(value) {\n    return !!value && !!value[DRAFT_STATE]\n}\n\nexport function isDraftable(value) {\n    if (!value || typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    if (!proto || proto === Object.prototype) return true\n    return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE]\n}\n\nexport function original(value) {\n    if (value && value[DRAFT_STATE]) {\n        return value[DRAFT_STATE].base\n    }\n    // otherwise return undefined\n}\n\nexport const assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport const ownKeys =\n    typeof Reflect !== \"undefined\" && Reflect.ownKeys\n        ? Reflect.ownKeys\n        : typeof Object.getOwnPropertySymbols !== \"undefined\"\n        ? obj =>\n              Object.getOwnPropertyNames(obj).concat(\n                  Object.getOwnPropertySymbols(obj)\n              )\n        : Object.getOwnPropertyNames\n\nexport function shallowCopy(base, invokeGetters = false) {\n    if (Array.isArray(base)) return base.slice()\n    const clone = Object.create(Object.getPrototypeOf(base))\n    ownKeys(base).forEach(key => {\n        if (key === DRAFT_STATE) {\n            return // Never copy over draft state.\n        }\n        const desc = Object.getOwnPropertyDescriptor(base, key)\n        if (desc.get) {\n            if (!invokeGetters) {\n                throw new Error(\"Immer drafts cannot have computed properties\")\n            }\n            desc.value = desc.get.call(base)\n        }\n        if (desc.enumerable) {\n            clone[key] = desc.value\n        } else {\n            Object.defineProperty(clone, key, {\n                value: desc.value,\n                writable: true,\n                configurable: true\n            })\n        }\n    })\n    return clone\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i], value)\n    } else {\n        ownKeys(value).forEach(key => cb(key, value[key], value))\n    }\n}\n\nexport function isEnumerable(base, prop) {\n    return Object.getOwnPropertyDescriptor(base, prop).enumerable\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","import {DRAFT_STATE} from \"./common\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n    constructor(parent) {\n        this.drafts = []\n        this.parent = parent\n\n        // Whenever the modified draft contains a draft from another scope, we\n        // need to prevent auto-freezing so the unowned draft can be finalized.\n        this.canAutoFreeze = true\n\n        // To avoid prototype lookups:\n        this.patches = null\n    }\n    usePatches(patchListener) {\n        if (patchListener) {\n            this.patches = []\n            this.inversePatches = []\n            this.patchListener = patchListener\n        }\n    }\n    revoke() {\n        this.leave()\n        this.drafts.forEach(revoke)\n        this.drafts = null // Make draft-related methods throw.\n    }\n    leave() {\n        if (this === ImmerScope.current) {\n            ImmerScope.current = this.parent\n        }\n    }\n}\n\nImmerScope.current = null\nImmerScope.enter = function() {\n    return (this.current = new ImmerScope(this.current))\n}\n\nfunction revoke(draft) {\n    draft[DRAFT_STATE].revoke()\n}\n","\"use strict\"\nimport {\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors = {}\n\nexport function willFinalize(scope, result, isReplaced) {\n    scope.drafts.forEach(draft => {\n        draft[DRAFT_STATE].finalizing = true\n    })\n    if (!isReplaced) {\n        if (scope.patches) {\n            markChangesRecursively(scope.drafts[0])\n        }\n        // This is faster when we don't care about which attributes changed.\n        markChangesSweep(scope.drafts)\n    }\n    // When a child draft is returned, look for changes.\n    else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n        markChangesSweep(scope.drafts)\n    }\n}\n\nexport function createProxy(base, parent) {\n    const isArray = Array.isArray(base)\n    const draft = clonePotentialDraft(base)\n    each(draft, prop => {\n        proxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n    })\n\n    // See \"proxy.js\" for property documentation.\n    const scope = parent ? parent.scope : ImmerScope.current\n    const state = {\n        scope,\n        modified: false,\n        finalizing: false, // es5 only\n        finalized: false,\n        assigned: {},\n        parent,\n        base,\n        draft,\n        copy: null,\n        revoke,\n        revoked: false // es5 only\n    }\n\n    createHiddenProperty(draft, DRAFT_STATE, state)\n    scope.drafts.push(draft)\n    return draft\n}\n\nfunction revoke() {\n    this.revoked = true\n}\n\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    assertUnrevoked(state)\n    const value = source(state)[prop]\n    // Drafts are only created for proxyable values that exist in the base state.\n    if (!state.finalizing && value === state.base[prop] && isDraftable(value)) {\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(value, state))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnrevoked(state)\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base) {\n    const state = base && base[DRAFT_STATE]\n    if (state) {\n        state.finalizing = true\n        const draft = shallowCopy(state.draft, true)\n        state.finalizing = false\n        return draft\n    }\n    return shallowCopy(base)\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n    let desc = descriptors[prop]\n    if (desc) {\n        desc.enumerable = enumerable\n    } else {\n        descriptors[prop] = desc = {\n            configurable: true,\n            enumerable,\n            get() {\n                return get(this[DRAFT_STATE], prop)\n            },\n            set(value) {\n                set(this[DRAFT_STATE], prop, value)\n            }\n        }\n    }\n    Object.defineProperty(draft, prop, desc)\n}\n\nfunction assertUnrevoked(state) {\n    if (state.revoked === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(source(state))\n        )\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts) {\n    // The natural order of drafts in the `scope` array is based on when they\n    // were accessed. By processing drafts in reverse natural order, we have a\n    // better chance of processing leaf nodes first. When a leaf node is known to\n    // have changed, we can avoid any traversal of its ancestor nodes.\n    for (let i = drafts.length - 1; i >= 0; i--) {\n        const state = drafts[i][DRAFT_STATE]\n        if (!state.modified) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[DRAFT_STATE]\n    if (!state) return\n    const {base, draft, assigned} = state\n    if (!Array.isArray(object)) {\n        // Look for added keys.\n        Object.keys(draft).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (base[key] === undefined && !has(base, key)) {\n                assigned[key] = true\n                markChanged(state)\n            } else if (!assigned[key]) {\n                // Only untouched properties trigger recursion.\n                markChangesRecursively(draft[key])\n            }\n        })\n        // Look for removed keys.\n        Object.keys(base).forEach(key => {\n            // The `undefined` check is a fast path for pre-existing keys.\n            if (draft[key] === undefined && !has(draft, key)) {\n                assigned[key] = false\n                markChanged(state)\n            }\n        })\n    } else if (hasArrayChanges(state)) {\n        markChanged(state)\n        assigned.length = true\n        if (draft.length < base.length) {\n            for (let i = draft.length; i < base.length; i++) assigned[i] = false\n        } else {\n            for (let i = base.length; i < draft.length; i++) assigned[i] = true\n        }\n        for (let i = 0; i < draft.length; i++) {\n            // Only untouched indices trigger recursion.\n            if (assigned[i] === undefined) markChangesRecursively(draft[i])\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const {base, draft} = state\n\n    // Search for added keys and changed keys. Start at the back, because\n    // non-numeric keys are ordered by time of definition on the object.\n    const keys = Object.keys(draft)\n    for (let i = keys.length - 1; i >= 0; i--) {\n        const key = keys[i]\n        const baseValue = base[key]\n        // The `undefined` check is a fast path for pre-existing keys.\n        if (baseValue === undefined && !has(base, key)) {\n            return true\n        }\n        // Once a base key is deleted, future changes go undetected, because its\n        // descriptor is erased. This branch detects any missed changes.\n        else {\n            const value = draft[key]\n            const state = value && value[DRAFT_STATE]\n            if (state ? state.base !== baseValue : !is(value, baseValue)) {\n                return true\n            }\n        }\n    }\n\n    // At this point, no keys were added or changed.\n    // Compare key count to determine if keys were deleted.\n    return keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state) {\n    const {draft} = state\n    if (draft.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","\"use strict\"\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraftable,\n    isDraft,\n    shallowCopy,\n    DRAFT_STATE\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\n// Do nothing before being finalized.\nexport function willFinalize() {}\n\nexport function createProxy(base, parent) {\n    const scope = parent ? parent.scope : ImmerScope.current\n    const state = {\n        // Track which produce call this is associated with.\n        scope,\n        // True for both shallow and deep changes.\n        modified: false,\n        // Used during finalization.\n        finalized: false,\n        // Track which properties have been assigned (true) or deleted (false).\n        assigned: {},\n        // The parent draft state.\n        parent,\n        // The base state.\n        base,\n        // The base proxy.\n        draft: null,\n        // Any property proxies.\n        drafts: {},\n        // The base copy with any updated values.\n        copy: null,\n        // Called by the `produce` function.\n        revoke: null\n    }\n\n    const {revoke, proxy} = Array.isArray(base)\n        ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n          // although state itself is an object\n          Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n\n    state.draft = proxy\n    state.revoke = revoke\n\n    scope.drafts.push(proxy)\n    return proxy\n}\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty() {\n        throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target.base)\n    },\n    setPrototypeOf() {\n        throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\narrayTraps.deleteProperty = function(state, prop) {\n    if (isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n    }\n    return objectTraps.deleteProperty.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n    if (prop !== \"length\" && isNaN(parseInt(prop))) {\n        throw new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n    }\n    return objectTraps.set.call(this, state[0], prop, value)\n}\n\n// returns the object we should be reading the current value from, which is base, until some change has been made\nfunction source(state) {\n    return state.copy || state.base\n}\n\nfunction get(state, prop) {\n    if (prop === DRAFT_STATE) return state\n    let {drafts} = state\n\n    // Check for existing draft in unmodified state.\n    if (!state.modified && has(drafts, prop)) {\n        return drafts[prop]\n    }\n\n    const value = source(state)[prop]\n    if (state.finalized || !isDraftable(value)) return value\n\n    // Check for existing draft in modified state.\n    if (state.modified) {\n        // Assigned values are never drafted. This catches any drafts we created, too.\n        if (value !== state.base[prop]) return value\n        // Store drafts on the copy (when one exists).\n        drafts = state.copy\n    }\n\n    return (drafts[prop] = createProxy(value, state))\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        // Optimize based on value's truthiness. Truthy values are guaranteed to\n        // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n        // values may be drafts, but falsy values are never drafts.\n        const isUnchanged = value\n            ? is(state.base[prop], value) || value === state.drafts[prop]\n            : is(state.base[prop], value) && prop in state.base\n        if (isUnchanged) return true\n        markChanged(state)\n    }\n    state.assigned[prop] = true\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (state.base[prop] !== undefined || prop in state.base) {\n        state.assigned[prop] = false\n        markChanged(state)\n    }\n    if (state.copy) delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = source(state)\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (desc) {\n        desc.writable = true\n        desc.configurable = !Array.isArray(owner) || prop !== \"length\"\n    }\n    return desc\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = assign(shallowCopy(state.base), state.drafts)\n        state.drafts = null\n        if (state.parent) markChanged(state.parent)\n    }\n}\n","import {each} from \"./common\"\n\nexport function generatePatches(state, basePath, patches, inversePatches) {\n    Array.isArray(state.base)\n        ? generateArrayPatches(state, basePath, patches, inversePatches)\n        : generateObjectPatches(state, basePath, patches, inversePatches)\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n    let {base, copy, assigned} = state\n\n    // Reduce complexity by ensuring `base` is never longer.\n    if (copy.length < base.length) {\n        ;[base, copy] = [copy, base]\n        ;[patches, inversePatches] = [inversePatches, patches]\n    }\n\n    const delta = copy.length - base.length\n\n    // Find the first replaced index.\n    let start = 0\n    while (base[start] === copy[start] && start < base.length) {\n        ++start\n    }\n\n    // Find the last replaced index. Search from the end to optimize splice patches.\n    let end = base.length\n    while (end > start && base[end - 1] === copy[end + delta - 1]) {\n        --end\n    }\n\n    // Process replaced indices.\n    for (let i = start; i < end; ++i) {\n        if (assigned[i] && copy[i] !== base[i]) {\n            const path = basePath.concat([i])\n            patches.push({\n                op: \"replace\",\n                path,\n                value: copy[i]\n            })\n            inversePatches.push({\n                op: \"replace\",\n                path,\n                value: base[i]\n            })\n        }\n    }\n\n    const useRemove = end != base.length\n    const replaceCount = patches.length\n\n    // Process added indices.\n    for (let i = end + delta - 1; i >= end; --i) {\n        const path = basePath.concat([i])\n        patches[replaceCount + i - end] = {\n            op: \"add\",\n            path,\n            value: copy[i]\n        }\n        if (useRemove) {\n            inversePatches.push({\n                op: \"remove\",\n                path\n            })\n        }\n    }\n\n    // One \"replace\" patch reverses all non-splicing \"add\" patches.\n    if (!useRemove) {\n        inversePatches.push({\n            op: \"replace\",\n            path: basePath.concat([\"length\"]),\n            value: base.length\n        })\n    }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n    const {base, copy} = state\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = base[key]\n        const value = copy[key]\n        const op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\"\n        if (origValue === value && op === \"replace\") return\n        const path = basePath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                ? {op: \"add\", path, value: origValue}\n                : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        const {path} = patch\n        if (path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            let base = draft\n            for (let i = 0; i < path.length - 1; i++) {\n                base = base[path[i]]\n                if (!base || typeof base !== \"object\")\n                    throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n            }\n            const key = path[path.length - 1]\n            switch (patch.op) {\n                case \"replace\":\n                    base[key] = patch.value\n                    break\n                case \"add\":\n                    if (Array.isArray(base)) {\n                        // TODO: support \"foo/-\" paths for appending to an array\n                        base.splice(key, 0, patch.value)\n                    } else {\n                        base[key] = patch.value\n                    }\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        base.splice(key, 1)\n                    } else {\n                        delete base[key]\n                    }\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import * as legacyProxy from \"./es5\"\nimport * as modernProxy from \"./proxy\"\nimport {applyPatches, generatePatches} from \"./patches\"\nimport {\n    assign,\n    each,\n    has,\n    is,\n    isDraft,\n    isDraftable,\n    isEnumerable,\n    shallowCopy,\n    DRAFT_STATE,\n    NOTHING\n} from \"./common\"\nimport {ImmerScope} from \"./scope\"\n\nfunction verifyMinified() {}\n\nconst configDefaults = {\n    useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n    autoFreeze:\n        typeof process !== \"undefined\"\n            ? process.env.NODE_ENV !== \"production\"\n            : verifyMinified.name === \"verifyMinified\",\n    onAssign: null,\n    onDelete: null,\n    onCopy: null\n}\n\nexport class Immer {\n    constructor(config) {\n        assign(this, configDefaults, config)\n        this.setUseProxies(this.useProxies)\n        this.produce = this.produce.bind(this)\n    }\n    produce(base, recipe, patchListener) {\n        // curried invocation\n        if (typeof base === \"function\" && typeof recipe !== \"function\") {\n            const defaultBase = recipe\n            recipe = base\n\n            // prettier-ignore\n            return (base = defaultBase, ...args) =>\n                this.produce(base, draft => recipe.call(draft, draft, ...args))\n        }\n\n        // prettier-ignore\n        {\n            if (typeof recipe !== \"function\") {\n                throw new Error(\"The first or second argument to `produce` must be a function\")\n            }\n            if (patchListener !== undefined && typeof patchListener !== \"function\") {\n                throw new Error(\"The third argument to `produce` must be a function or undefined\")\n            }\n        }\n\n        let result\n\n        // Only plain objects, arrays, and \"immerable classes\" are drafted.\n        if (isDraftable(base)) {\n            const scope = ImmerScope.enter()\n            const proxy = this.createProxy(base)\n            let hasError = true\n            try {\n                result = recipe.call(proxy, proxy)\n                hasError = false\n            } finally {\n                // finally instead of catch + rethrow better preserves original stack\n                if (hasError) scope.revoke()\n                else scope.leave()\n            }\n            if (result instanceof Promise) {\n                return result.then(\n                    result => {\n                        scope.usePatches(patchListener)\n                        return this.processResult(result, scope)\n                    },\n                    error => {\n                        scope.revoke()\n                        throw error\n                    }\n                )\n            }\n            scope.usePatches(patchListener)\n            return this.processResult(result, scope)\n        } else {\n            result = recipe(base)\n            if (result === undefined) return base\n            return result !== NOTHING ? result : undefined\n        }\n    }\n    createDraft(base) {\n        if (!isDraftable(base)) {\n            throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\") // prettier-ignore\n        }\n        const scope = ImmerScope.enter()\n        const proxy = this.createProxy(base)\n        proxy[DRAFT_STATE].isManual = true\n        scope.leave()\n        return proxy\n    }\n    finishDraft(draft, patchListener) {\n        const state = draft && draft[DRAFT_STATE]\n        if (!state || !state.isManual) {\n            throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\") // prettier-ignore\n        }\n        if (state.finalized) {\n            throw new Error(\"The given draft is already finalized\") // prettier-ignore\n        }\n        const {scope} = state\n        scope.usePatches(patchListener)\n        return this.processResult(undefined, scope)\n    }\n    setAutoFreeze(value) {\n        this.autoFreeze = value\n    }\n    setUseProxies(value) {\n        this.useProxies = value\n        assign(this, value ? modernProxy : legacyProxy)\n    }\n    applyPatches(base, patches) {\n        // Mutate the base state when a draft is passed.\n        if (isDraft(base)) {\n            return applyPatches(base, patches)\n        }\n        // Otherwise, produce a copy of the base state.\n        return this.produce(base, draft => applyPatches(draft, patches))\n    }\n    /** @internal */\n    processResult(result, scope) {\n        const baseDraft = scope.drafts[0]\n        const isReplaced = result !== undefined && result !== baseDraft\n        this.willFinalize(scope, result, isReplaced)\n        if (isReplaced) {\n            if (baseDraft[DRAFT_STATE].modified) {\n                scope.revoke()\n                throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n            }\n            if (isDraftable(result)) {\n                // Finalize the result in case it contains (or is) a subset of the draft.\n                result = this.finalize(result, null, scope)\n            }\n            if (scope.patches) {\n                scope.patches.push({\n                    op: \"replace\",\n                    path: [],\n                    value: result\n                })\n                scope.inversePatches.push({\n                    op: \"replace\",\n                    path: [],\n                    value: baseDraft[DRAFT_STATE].base\n                })\n            }\n        } else {\n            // Finalize the base draft.\n            result = this.finalize(baseDraft, [], scope)\n        }\n        scope.revoke()\n        if (scope.patches) {\n            scope.patchListener(scope.patches, scope.inversePatches)\n        }\n        return result !== NOTHING ? result : undefined\n    }\n    /**\n     * @internal\n     * Finalize a draft, returning either the unmodified base state or a modified\n     * copy of the base state.\n     */\n    finalize(draft, path, scope) {\n        const state = draft[DRAFT_STATE]\n        if (!state) {\n            if (Object.isFrozen(draft)) return draft\n            return this.finalizeTree(draft, null, scope)\n        }\n        // Never finalize drafts owned by another scope.\n        if (state.scope !== scope) {\n            return draft\n        }\n        if (!state.modified) {\n            return state.base\n        }\n        if (!state.finalized) {\n            state.finalized = true\n            this.finalizeTree(state.draft, path, scope)\n\n            if (this.onDelete) {\n                // The `assigned` object is unreliable with ES5 drafts.\n                if (this.useProxies) {\n                    const {assigned} = state\n                    for (const prop in assigned) {\n                        if (!assigned[prop]) this.onDelete(state, prop)\n                    }\n                } else {\n                    const {base, copy} = state\n                    each(base, prop => {\n                        if (!has(copy, prop)) this.onDelete(state, prop)\n                    })\n                }\n            }\n            if (this.onCopy) {\n                this.onCopy(state)\n            }\n\n            // At this point, all descendants of `state.copy` have been finalized,\n            // so we can be sure that `scope.canAutoFreeze` is accurate.\n            if (this.autoFreeze && scope.canAutoFreeze) {\n                Object.freeze(state.copy)\n            }\n\n            if (path && scope.patches) {\n                generatePatches(\n                    state,\n                    path,\n                    scope.patches,\n                    scope.inversePatches\n                )\n            }\n        }\n        return state.copy\n    }\n    /**\n     * @internal\n     * Finalize all drafts in the given state tree.\n     */\n    finalizeTree(root, rootPath, scope) {\n        const state = root[DRAFT_STATE]\n        if (state) {\n            if (!this.useProxies) {\n                state.finalizing = true\n                state.copy = shallowCopy(state.draft, true)\n                state.finalizing = false\n            }\n            root = state.copy\n        }\n\n        const needPatches = !!rootPath && !!scope.patches\n        const finalizeProperty = (prop, value, parent) => {\n            if (value === parent) {\n                throw Error(\"Immer forbids circular references\")\n            }\n\n            // In the `finalizeTree` method, only the `root` object may be a draft.\n            const isDraftProp = !!state && parent === root\n\n            if (isDraft(value)) {\n                const path =\n                    isDraftProp && needPatches && !state.assigned[prop]\n                        ? rootPath.concat(prop)\n                        : null\n\n                // Drafts owned by `scope` are finalized here.\n                value = this.finalize(value, path, scope)\n\n                // Drafts from another scope must prevent auto-freezing.\n                if (isDraft(value)) {\n                    scope.canAutoFreeze = false\n                }\n\n                // Preserve non-enumerable properties.\n                if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n                    parent[prop] = value\n                } else {\n                    Object.defineProperty(parent, prop, {value})\n                }\n\n                // Unchanged drafts are never passed to the `onAssign` hook.\n                if (isDraftProp && value === state.base[prop]) return\n            }\n            // Unchanged draft properties are ignored.\n            else if (isDraftProp && is(value, state.base[prop])) {\n                return\n            }\n            // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n            else if (isDraftable(value) && !Object.isFrozen(value)) {\n                each(value, finalizeProperty)\n            }\n\n            if (isDraftProp && this.onAssign) {\n                this.onAssign(state, prop, value)\n            }\n        }\n\n        each(root, finalizeProperty)\n        return root\n    }\n}\n","import {Immer} from \"./immer\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce = immer.produce\nexport default produce\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\nexport {\n    original,\n    isDraft,\n    isDraftable,\n    NOTHING as nothing,\n    DRAFTABLE as immerable\n} from \"./common\"\n\nexport {Immer}\n"],"names":["NOTHING","Symbol","DRAFTABLE","for","DRAFT_STATE","isDraft","value","isDraftable","Array","isArray","proto","Object","getPrototypeOf","prototype","constructor","const","assign","target","let","key","has","ownKeys","Reflect","getOwnPropertySymbols","obj","getOwnPropertyNames","concat","shallowCopy","base","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","defineProperty","writable","configurable","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","ImmerScope","parent","drafts","canAutoFreeze","patches","revoke","draft","usePatches","patchListener","inversePatches","leave","this","current","enter","descriptors","createProxy","clonePotentialDraft","state","assertUnrevoked","source","finalizing","prepareCopy","copy","set","assigned","modified","markChanged","proxyProperty","scope","finalized","revoked","push","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","keys","baseValue","undefined","descriptor","result","isReplaced","markChangesRecursively","object","Proxy","revocable","arrayTraps","objectTraps","proxy","isUnchanged","owner","setPrototypeOf","fn","arguments","apply","deleteProperty","isNaN","parseInt","generatePatches","basePath","delta","start","end","path","op","useRemove","replaceCount","generateArrayPatches","assignedValue","origValue","generateObjectPatches","applyPatches","patch","join","splice","configDefaults","useProxies","autoFreeze","process","env","NODE_ENV","name","onAssign","onDelete","onCopy","Immer","config","setUseProxies","produce","bind","recipe","defaultBase","args","hasError","Promise","then","processResult","error","createDraft","isManual","finishDraft","setAutoFreeze","modernProxy","legacyProxy","baseDraft","willFinalize","finalize","isFrozen","finalizeTree","freeze","root","rootPath","needPatches","finalizeProperty","isDraftProp","immer"],"mappings":"wMAAaA,EACS,oBAAXC,OACDA,OAAO,qBACP,IAAE,kBAAkB,KAEjBC,EACS,oBAAXD,OACDA,OAAOE,IAAI,mBACX,qBAEGC,EACS,oBAAXH,OAAyBA,OAAOE,IAAI,eAAiB,iBAEzD,SAASE,EAAQC,WACXA,KAAWA,EAAMF,GAGvB,SAASG,EAAYD,OACnBA,GAA0B,iBAAVA,EAAoB,OAAO,KAC5CE,MAAMC,QAAQH,GAAQ,OAAO,MAC3BI,EAAQC,OAAOC,eAAeN,UAC/BI,GAASA,IAAUC,OAAOE,cACtBP,EAAMJ,MAAgBI,EAAMQ,YAAYZ,IAU9Ca,IAAMC,EACTL,OAAOK,QACP,SAAgBC,EAAQX,OACfY,IAAIC,KAAOb,EACRc,EAAId,EAAOa,KACXF,EAAOE,GAAOb,EAAMa,WAGrBF,GAGFI,EACU,oBAAZC,SAA2BA,QAAQD,QACpCC,QAAQD,aACgC,IAAjCV,OAAOY,+BACdC,UACIb,OAAOc,oBAAoBD,GAAKE,OAC5Bf,OAAOY,sBAAsBC,KAErCb,OAAOc,oBAEV,SAASE,EAAYC,EAAMC,sBAAgB,GAC1CrB,MAAMC,QAAQmB,GAAO,OAAOA,EAAKE,YAC/BC,EAAQpB,OAAOqB,OAAOrB,OAAOC,eAAegB,WAClDP,EAAQO,GAAMK,iBAAQd,MACdA,IAAQf,OAGN8B,EAAOvB,OAAOwB,yBAAyBP,EAAMT,MAC/Ce,EAAKE,IAAK,KACLP,QACK,IAAIQ,MAAM,gDAEpBH,EAAK5B,MAAQ4B,EAAKE,IAAIE,KAAKV,GAE3BM,EAAKK,WACLR,EAAMZ,GAAOe,EAAK5B,MAElBK,OAAO6B,eAAeT,EAAOZ,EAAK,CAC9Bb,MAAO4B,EAAK5B,MACZmC,UAAU,EACVC,cAAc,OAInBX,EAGJ,SAASY,EAAKrC,EAAOsC,MACpBpC,MAAMC,QAAQH,OACTY,IAAI2B,EAAI,EAAGA,EAAIvC,EAAMwC,OAAQD,IAAKD,EAAGC,EAAGvC,EAAMuC,GAAIvC,QAEvDe,EAAQf,GAAO2B,iBAAQd,UAAOyB,EAAGzB,EAAKb,EAAMa,GAAMb,KAInD,SAASyC,EAAanB,EAAMoB,UACxBrC,OAAOwB,yBAAyBP,EAAMoB,GAAMT,WAGhD,SAASnB,EAAI6B,EAAOD,UAChBrC,OAAOE,UAAUqC,eAAeZ,KAAKW,EAAOD,GAGhD,SAASG,EAAGC,EAAGC,UAEdD,IAAMC,EACO,IAAND,GAAW,EAAIA,GAAM,EAAIC,EAEzBD,GAAMA,GAAKC,GAAMA,EClGzB,IAAMC,EACTxC,SAAYyC,QACHC,OAAS,QACTD,OAASA,OAITE,eAAgB,OAGhBC,QAAU,MA0BvB,SAASC,EAAOC,GACZA,EAAMxD,GAAauD,SAzBnBE,YAAAA,oBAAWC,GACHA,SACKJ,QAAU,QACVK,eAAiB,QACjBD,cAAgBA,IAG7BH,YAAAA,uBACSK,aACAR,OAAOvB,QAAQ0B,QACfH,OAAS,MAElBQ,YAAAA,iBACQC,OAASX,EAAWY,UACpBZ,EAAWY,QAAUD,KAAKV,SAKtCD,EAAWY,QAAU,KACrBZ,EAAWa,MAAQ,kBACPF,KAAKC,QAAU,IAAIZ,EAAWW,KAAKC,UCrB/CnD,IAAMqD,EAAc,GAmBb,SAASC,EAAYzC,EAAM2B,OACxB9C,EAAUD,MAAMC,QAAQmB,GACxBgC,EAAQU,EAAoB1C,GAClCe,EAAKiB,WAAOZ,IA6EhB,SAAuBY,EAAOZ,EAAMT,OAC5BL,EAAOkC,EAAYpB,GACnBd,EACAA,EAAKK,WAAaA,EAElB6B,EAAYpB,GAAQd,EAAO,CACvBQ,cAAc,aACdH,EACAH,sBApDZ,SAAamC,EAAOvB,GAChBwB,EAAgBD,OACVjE,EAAQmE,EAAOF,GAAOvB,OAEvBuB,EAAMG,YAAcpE,IAAUiE,EAAM3C,KAAKoB,IAASzC,EAAYD,UAC/DqE,EAAYJ,GACJA,EAAMK,KAAK5B,GAAQqB,EAAY/D,EAAOiE,UAE3CjE,EA6CY8B,CAAI6B,KAAK7D,GAAc4C,IAElC6B,aAAIvE,IA5ChB,SAAaiE,EAAOvB,EAAM1C,MACtBkE,EAAgBD,GAChBA,EAAMO,SAAS9B,IAAQ,GAClBuB,EAAMQ,SAAU,IACb5B,EAAGsB,EAAOF,GAAOvB,GAAO1C,GAAQ,OACpC0E,EAAYT,GACZI,EAAYJ,GAEhBA,EAAMK,KAAK5B,GAAQ1C,EAqCPuE,CAAIZ,KAAK7D,GAAc4C,EAAM1C,KAIzCK,OAAO6B,eAAeoB,EAAOZ,EAAMd,GA5F/B+C,CAAcrB,EAAOZ,EAAMvC,GAAWsC,EAAanB,EAAMoB,UA6MnC/B,EAAQ+B,EAAM1C,EAzMlC4E,EAAQ3B,EAASA,EAAO2B,MAAQ5B,EAAWY,eAyMvBjD,EA1LL2C,EA0LaZ,EA1LN5C,EA0LYE,EAxM1B,OACV4E,EACAH,UAAU,EACVL,YAAY,EACZS,WAAW,EACXL,SAAU,UACVvB,OACA3B,QACAgC,EACAgB,KAAM,YACNjB,EACAyB,SAAS,GA8LbzE,OAAO6B,eAAevB,EAAQ+B,EAAM,CAChC1C,MAAOA,EACPiC,YAAY,EACZE,UAAU,IA7LdyC,EAAM1B,OAAO6B,KAAKzB,GACXA,EAGX,SAASD,SACAyB,SAAU,EAGnB,SAASX,EAAOF,UACLA,EAAMK,MAAQL,EAAM3C,KAyB/B,SAASoD,EAAYT,GACZA,EAAMQ,WACPR,EAAMQ,UAAW,EACbR,EAAMhB,QAAQyB,EAAYT,EAAMhB,SAI5C,SAASoB,EAAYJ,GACZA,EAAMK,OAAML,EAAMK,KAAON,EAAoBC,EAAM3C,OAG5D,SAAS0C,EAAoB1C,OACnB2C,EAAQ3C,GAAQA,EAAKxB,MACvBmE,EAAO,CACPA,EAAMG,YAAa,MACbd,EAAQjC,EAAY4C,EAAMX,OAAO,UACvCW,EAAMG,YAAa,EACZd,SAEJjC,EAAYC,GAsBvB,SAAS4C,EAAgBD,OACC,IAAlBA,EAAMa,QACN,MAAM,IAAI/C,MACN,uHACIiD,KAAKC,UAAUd,EAAOF,KAKtC,SAASiB,EAAiBhC,OAKjBtC,IAAI2B,EAAIW,EAAOV,OAAS,EAAGD,GAAK,EAAGA,IAAK,KACnC0B,EAAQf,EAAOX,GAAGzC,GACnBmE,EAAMQ,WACHvE,MAAMC,QAAQ8D,EAAM3C,MAChB6D,EAAgBlB,IAAQS,EAAYT,GACjCmB,EAAiBnB,IAAQS,EAAYT,KA6C5D,SAASmB,EAAiBnB,8BAKhBoB,EAAOhF,OAAOgF,KAAK/B,GAChBf,EAAI8C,EAAK7C,OAAS,EAAGD,GAAK,EAAGA,IAAK,KACjC1B,EAAMwE,EAAK9C,GACX+C,EAAYhE,EAAKT,WAEL0E,IAAdD,IAA4BxE,EAAIQ,EAAMT,UAC/B,MAKDb,EAAQsD,EAAMzC,GACdoD,EAAQjE,GAASA,EAAMF,MACzBmE,EAAQA,EAAM3C,OAASgE,GAAazC,EAAG7C,EAAOsF,UACvC,SAOZD,EAAK7C,SAAWnC,OAAOgF,KAAK/D,GAAMkB,OAG7C,SAAS2C,EAAgBlB,GACdX,iBACHA,EAAMd,SAAWyB,EAAM3C,KAAKkB,OAAQ,OAAO,MAQzCgD,EAAanF,OAAOwB,yBAAyByB,EAAOA,EAAMd,OAAS,YAErEgD,GAAeA,EAAW1D,uCA7N3B,SAAsB8C,EAAOa,EAAQC,GACxCd,EAAM1B,OAAOvB,iBAAQ2B,GACjBA,EAAMxD,GAAasE,YAAa,IAE/BsB,EAQI3F,EAAQ0F,IAAWA,EAAO3F,GAAa8E,QAAUA,GACtDM,EAAiBN,EAAM1B,SARnB0B,EAAMxB,SAuIlB,SAASuC,EAAuBC,MACvBA,GAA4B,iBAAXA,OAChB3B,EAAQ2B,EAAO9F,MAChBmE,0CAEA/D,MAAMC,QAAQyF,IAoBZ,GAAIT,EAAgBlB,GAAQ,IAC/BS,EAAYT,GACZO,EAAShC,QAAS,EACdc,EAAMd,OAASlB,EAAKkB,WACf5B,IAAI2B,EAAIe,EAAMd,OAAQD,EAAIjB,EAAKkB,OAAQD,IAAKiC,EAASjC,IAAK,WAE1D3B,IAAI2B,EAAIjB,EAAKkB,OAAQD,EAAIe,EAAMd,OAAQD,IAAKiC,EAASjC,IAAK,MAE9D3B,IAAI2B,EAAI,EAAGA,EAAIe,EAAMd,OAAQD,SAEVgD,IAAhBf,EAASjC,IAAkBoD,EAAuBrC,EAAMf,UA5BhElC,OAAOgF,KAAK/B,GAAO3B,iBAAQd,QAEL0E,IAAdjE,EAAKT,IAAuBC,EAAIQ,EAAMT,GAG9B2D,EAAS3D,IAEjB8E,EAAuBrC,EAAMzC,KAJ7B2D,EAAS3D,IAAO,EAChB6D,EAAYT,MAOpB5D,OAAOgF,KAAK/D,GAAMK,iBAAQd,QAEH0E,IAAfjC,EAAMzC,IAAuBC,EAAIwC,EAAOzC,KACxC2D,EAAS3D,IAAO,EAChB6D,EAAYT,QA5JhB0B,CAAuBf,EAAM1B,OAAO,IAGxCgC,EAAiBN,EAAM1B,0BCVxB,SAASa,EAAYzC,EAAM2B,OACxB2B,EAAQ3B,EAASA,EAAO2B,MAAQ5B,EAAWY,QAC3CK,EAAQ,OAEVW,EAEAH,UAAU,EAEVI,WAAW,EAEXL,SAAU,UAEVvB,OAEA3B,EAEAgC,MAAO,KAEPJ,OAAQ,GAERoB,KAAM,KAENjB,OAAQ,QAGYnD,MAAMC,QAAQmB,GAGhCuE,MAAMC,UAAU,CAAC7B,GAAQ8B,GACzBF,MAAMC,UAAU7B,EAAO+B,+BAE7B/B,EAAMX,MAAQ2C,EACdhC,EAAMZ,OAASA,EAEfuB,EAAM1B,OAAO6B,KAAKkB,GACXA,EAGXxF,IAAMuF,EAAc,KA+CpB,SAAa/B,EAAOvB,MACZA,IAAS5C,EAAa,OAAOmE,EAC5Bf,mBAGAe,EAAMQ,UAAY3D,EAAIoC,EAAQR,UACxBQ,EAAOR,OAGZ1C,EAAQmE,EAAOF,GAAOvB,MACxBuB,EAAMY,YAAc5E,EAAYD,GAAQ,OAAOA,KAG/CiE,EAAMQ,SAAU,IAEZzE,IAAUiE,EAAM3C,KAAKoB,GAAO,OAAO1C,EAEvCkD,EAASe,EAAMK,YAGXpB,EAAOR,GAAQqB,EAAY/D,EAAOiE,IAjE1CnD,aAAIH,EAAQ+B,UACDA,KAAQyB,EAAOxD,IAE1BI,iBAAQJ,UACGK,QAAQD,QAAQoD,EAAOxD,SAgEtC,SAAasD,EAAOvB,EAAM1C,OACjBiE,EAAMQ,SAAU,KAIXyB,EAAclG,EACd6C,EAAGoB,EAAM3C,KAAKoB,GAAO1C,IAAUA,IAAUiE,EAAMf,OAAOR,GACtDG,EAAGoB,EAAM3C,KAAKoB,GAAO1C,IAAU0C,KAAQuB,EAAM3C,QAC/C4E,EAAa,OAAO,EACxBxB,EAAYT,UAEhBA,EAAMO,SAAS9B,IAAQ,EACvBuB,EAAMK,KAAK5B,GAAQ1C,GACZ,kBAGX,SAAwBiE,EAAOvB,SAEF6C,IAArBtB,EAAM3C,KAAKoB,IAAuBA,KAAQuB,EAAM3C,QAChD2C,EAAMO,SAAS9B,IAAQ,EACvBgC,EAAYT,IAEZA,EAAMK,aAAaL,EAAMK,KAAK5B,UAC3B,4BAGX,SAAkCuB,EAAOvB,OAC/ByD,EAAQhC,EAAOF,GACfrC,EAAOZ,QAAQa,yBAAyBsE,EAAOzD,GACjDd,IACAA,EAAKO,UAAW,EAChBP,EAAKQ,cAAgBlC,MAAMC,QAAQgG,IAAmB,WAATzD,UAE1Cd,GA5FPM,gCACU,IAAIH,MAAM,6DAEpBzB,wBAAeK,UACJN,OAAOC,eAAeK,EAAOW,OAExC8E,gCACU,IAAIrE,MAAM,8DAIlBgE,EAAa,GAqBnB,SAAS5B,EAAOF,UACLA,EAAMK,MAAQL,EAAM3C,KA8D/B,SAASoD,EAAYT,GACZA,EAAMQ,WACPR,EAAMQ,UAAW,EACjBR,EAAMK,KAAO5D,EAAOW,EAAY4C,EAAM3C,MAAO2C,EAAMf,QACnDe,EAAMf,OAAS,KACXe,EAAMhB,QAAQyB,EAAYT,EAAMhB,SAxF5CZ,EAAK2D,WAAcnF,EAAKwF,GACpBN,EAAWlF,GAAO,kBACdyF,UAAU,GAAKA,UAAU,GAAG,GACrBD,EAAGE,MAAM5C,KAAM2C,cAG9BP,EAAWS,eAAiB,SAASvC,EAAOvB,MACpC+D,MAAMC,SAAShE,UACT,IAAIX,MAAM,qDAEbiE,EAAYQ,eAAexE,KAAK2B,KAAMM,EAAM,GAAIvB,IAE3DqD,EAAWxB,IAAM,SAASN,EAAOvB,EAAM1C,MACtB,WAAT0C,GAAqB+D,MAAMC,SAAShE,UAC9B,IAAIX,MAAM,8EAEbiE,EAAYzB,IAAIvC,KAAK2B,KAAMM,EAAM,GAAIvB,EAAM1C,4EC3FtC2G,EAAgB1C,EAAO2C,EAAUxD,EAASK,GACtDvD,MAAMC,QAAQ8D,EAAM3C,MAKxB,SAA8B2C,EAAO2C,EAAUxD,EAASK,0CAIhDa,EAAK9B,OAASlB,EAAKkB,SACjBlB,KAAc,CAACgD,EAAMhD,OAAfgD,OACNlB,KAA2B,CAACK,EAAgBL,OAAnCK,YAGToD,EAAQvC,EAAK9B,OAASlB,EAAKkB,OAG7BsE,EAAQ,OACLxF,EAAKwF,KAAWxC,EAAKwC,IAAUA,EAAQxF,EAAKkB,UAC7CsE,MAIFC,EAAMzF,EAAKkB,YACRuE,EAAMD,GAASxF,EAAKyF,EAAM,KAAOzC,EAAKyC,EAAMF,EAAQ,MACrDE,MAIDnG,IAAI2B,EAAIuE,EAAOvE,EAAIwE,IAAOxE,KACvBiC,EAASjC,IAAM+B,EAAK/B,KAAOjB,EAAKiB,GAAI,KAC9ByE,EAAOJ,EAASxF,OAAO,CAACmB,IAC9Ba,EAAQ2B,KAAK,CACTkC,GAAI,eACJD,EACAhH,MAAOsE,EAAK/B,KAEhBkB,EAAesB,KAAK,CAChBkC,GAAI,eACJD,EACAhH,MAAOsB,EAAKiB,aAKlB2E,EAAYH,GAAOzF,EAAKkB,OACxB2E,EAAe/D,EAAQZ,OAGpBD,EAAIwE,EAAMF,EAAQ,EAAGtE,GAAKwE,IAAOxE,EAAG,KACnCyE,EAAOJ,EAASxF,OAAO,CAACmB,IAC9Ba,EAAQ+D,EAAe5E,EAAIwE,GAAO,CAC9BE,GAAI,WACJD,EACAhH,MAAOsE,EAAK/B,IAEZ2E,GACAzD,EAAesB,KAAK,CAChBkC,GAAI,cACJD,IAMPE,GACDzD,EAAesB,KAAK,CAChBkC,GAAI,UACJD,KAAMJ,EAASxF,OAAO,CAAC,WACvBpB,MAAOsB,EAAKkB,SApEd4E,CAAqBnD,EAAO2C,EAAUxD,EAASK,GAyEzD,SAA+BQ,EAAO2C,EAAUxD,EAASK,yBAErDpB,EAAK4B,EAAMO,kBAAW3D,EAAKwG,OACjBC,EAAYhG,EAAKT,GACjBb,EAAQsE,EAAKzD,GACboG,EAAMI,EAA2BxG,KAAOS,EAAO,UAAY,MAArC,YACxBgG,IAActH,GAAgB,YAAPiH,OACrBD,EAAOJ,EAASxF,OAAOP,GAC7BuC,EAAQ2B,KAAY,WAAPkC,EAAkB,IAACA,OAAID,GAAQ,IAACC,OAAID,QAAMhH,IACvDyD,EAAesB,KACJ,QAAPkC,EACM,CAACA,GAAI,cAAUD,GACR,WAAPC,EACA,CAACA,GAAI,WAAOD,EAAMhH,MAAOsH,GACzB,CAACL,GAAI,eAAWD,EAAMhH,MAAOsH,OAtFrCC,CAAsBtD,EAAO2C,EAAUxD,EAASK,GA2FnD,SAAS+D,EAAalE,EAAOF,OAC3BxC,IAAI2B,EAAI,EAAGA,EAAIa,EAAQZ,OAAQD,IAAK,KAC/BkF,EAAQrE,EAAQb,eAEF,IAAhByE,EAAKxE,QAA6B,YAAbiF,EAAMR,GAC3B3D,EAAQmE,EAAMzH,UACX,SACCsB,EAAOgC,EACFf,EAAI,EAAGA,EAAIyE,EAAKxE,OAAS,EAAGD,SACjCjB,EAAOA,EAAK0F,EAAKzE,MACY,iBAATjB,EAChB,MAAM,IAAIS,MAAM,6CAA+CiF,EAAKU,KAAK,UAE3E7G,EAAMmG,EAAKA,EAAKxE,OAAS,UACvBiF,EAAMR,QACL,UACD3F,EAAKT,GAAO4G,EAAMzH,gBAEjB,MACGE,MAAMC,QAAQmB,GAEdA,EAAKqG,OAAO9G,EAAK,EAAG4G,EAAMzH,OAE1BsB,EAAKT,GAAO4G,EAAMzH,gBAGrB,SACGE,MAAMC,QAAQmB,GACdA,EAAKqG,OAAO9G,EAAK,UAEVS,EAAKT,uBAIV,IAAIkB,MAAM,gCAAkC0F,EAAMR,aAIjE3D,ECnHX7C,IAAMmH,EAAiB,CACnBC,WAA6B,oBAAVhC,OAA4C,oBAAZ7E,QACnD8G,WACuB,oBAAZC,QACwB,eAAzBA,QAAQC,IAAIC,SACY,gCAATC,KACzBC,SAAU,KACVC,SAAU,KACVC,OAAQ,MAGCC,EACT9H,SAAY+H,KACD5E,KAAMiE,EAAgBW,QACxBC,cAAc7E,KAAKkE,iBACnBY,QAAU9E,KAAK8E,QAAQC,KAAK/E,OAErC8E,YAAAA,iBAAQnH,EAAMqH,EAAQnF,OAqBdiC,YAnBgB,mBAATnE,GAAyC,mBAAXqH,EAAuB,KACtDC,EAAcD,WACXrH,WAGDA,kBAAOsH,wEACXjF,EAAK8E,QAAQnH,WAAMgC,UAASqF,EAAO3G,cAAKsB,EAAOA,UAAUuF,UAKvC,mBAAXF,QACD,IAAI5G,MAAM,wEAEEwD,IAAlB/B,GAAwD,mBAAlBA,QAChC,IAAIzB,MAAM,sEAOpB9B,EAAYqB,GAAO,KACbsD,EAAQ5B,EAAWa,QACnBoC,EAAQtC,KAAKI,YAAYzC,GAC3BwH,GAAW,QAEFH,EAAO3G,KAAKiE,EAAOA,MACjB,UAGP6C,EAAUlE,EAAMvB,SACfuB,EAAMlB,eAEX+B,aAAkBsD,QACXtD,EAAOuD,cACVvD,UACIb,EAAMrB,WAAWC,GACVG,EAAKsF,cAAcxD,EAAQb,aAEtCsE,SACItE,EAAMvB,SACA6F,KAIlBtE,EAAMrB,WAAWC,GACVG,KAAKsF,cAAcxD,EAAQb,gBAGnBW,KADfE,EAASkD,EAAOrH,IACiBA,EAC1BmE,IAAW/F,EAAU+F,OAASF,GAG7C4D,YAAAA,qBAAY7H,OACHrB,EAAYqB,SACP,IAAIS,MAAM,gGAEd6C,EAAQ5B,EAAWa,QACnBoC,EAAQtC,KAAKI,YAAYzC,YACzBxB,GAAasJ,UAAW,EAC9BxE,EAAMlB,QACCuC,GAEXoD,YAAAA,qBAAY/F,EAAOE,OACTS,EAAQX,GAASA,EAAMxD,OACxBmE,IAAUA,EAAMmF,eACX,IAAIrH,MAAM,gFAEhBkC,EAAMY,gBACA,IAAI9C,MAAM,wCAEb6C,qBACPA,EAAMrB,WAAWC,GACVG,KAAKsF,mBAAc1D,EAAWX,IAEzC0E,YAAAA,uBAActJ,QACL8H,WAAa9H,GAEtBwI,YAAAA,uBAAcxI,QACL6H,WAAa7H,IACX2D,KAAM3D,EAAQuJ,EAAcC,IAEvChC,YAAAA,sBAAalG,EAAM8B,UAEXrD,EAAQuB,GACDkG,EAAalG,EAAM8B,GAGvBO,KAAK8E,QAAQnH,WAAMgC,UAASkE,EAAalE,EAAOF,MAG3D6F,YAAAA,uBAAcxD,EAAQb,OACZ6E,EAAY7E,EAAM1B,OAAO,GACzBwC,OAAwBH,IAAXE,GAAwBA,IAAWgE,UACjDC,aAAa9E,EAAOa,EAAQC,GAC7BA,EAAY,IACR+D,EAAU3J,GAAa2E,eACvBG,EAAMvB,SACA,IAAItB,MAAM,qHAEhB9B,EAAYwF,KAEZA,EAAS9B,KAAKgG,SAASlE,EAAQ,KAAMb,IAErCA,EAAMxB,UACNwB,EAAMxB,QAAQ2B,KAAK,IACX,eACE,SACCU,IAEXb,EAAMnB,eAAesB,KAAK,IAClB,eACE,GACN/E,MAAOyJ,EAAU3J,GAAawB,aAKtCmE,EAAS9B,KAAKgG,SAASF,EAAW,GAAI7E,UAE1CA,EAAMvB,SACFuB,EAAMxB,SACNwB,EAAMpB,cAAcoB,EAAMxB,QAASwB,EAAMnB,gBAEtCgC,IAAW/F,EAAU+F,OAASF,GAOzCoE,YAAAA,kBAASrG,EAAO0D,EAAMpC,cACZX,EAAQX,EAAMxD,OACfmE,SACG5D,OAAOuJ,SAAStG,GAAeA,EAC5BK,KAAKkG,aAAavG,EAAO,KAAMsB,MAGtCX,EAAMW,QAAUA,SACTtB,MAENW,EAAMQ,gBACAR,EAAM3C,SAEZ2C,EAAMY,UAAW,IAClBZ,EAAMY,WAAY,OACbgF,aAAa5F,EAAMX,MAAO0D,EAAMpC,GAEjCjB,KAAKyE,YAEDzE,KAAKkE,WAAY,CACVrD,qBACF/D,IAAMiC,KAAQ8B,EACVA,EAAS9B,IAAOiB,KAAKyE,SAASnE,EAAOvB,OAE3C,uBAEHL,EAAKf,WAAMoB,GACF5B,EAAIwD,EAAM5B,IAAOiB,EAAKyE,SAASnE,EAAOvB,KAInDiB,KAAK0E,aACAA,OAAOpE,GAKZN,KAAKmE,YAAclD,EAAMzB,sBAClB2G,OAAO7F,EAAMK,MAGpB0C,GAAQpC,EAAMxB,SACduD,EACI1C,EACA+C,EACApC,EAAMxB,QACNwB,EAAMnB,uBAIXQ,EAAMK,MAMjBuF,YAAAA,sBAAaE,EAAMC,EAAUpF,cACnBX,EAAQ8F,EAAKjK,GACfmE,IACKN,KAAKkE,aACN5D,EAAMG,YAAa,EACnBH,EAAMK,KAAOjD,EAAY4C,EAAMX,OAAO,GACtCW,EAAMG,YAAa,GAEvB2F,EAAO9F,EAAMK,UAGX2F,IAAgBD,KAAcpF,EAAMxB,QACpC8G,WAAoBxH,EAAM1C,EAAOiD,MAC/BjD,IAAUiD,QACJlB,MAAM,yCAIVoI,IAAgBlG,GAAShB,IAAW8G,KAEtChK,EAAQC,GAAQ,KACVgH,EACFmD,GAAeF,IAAgBhG,EAAMO,SAAS9B,GACxCsH,EAAS5I,OAAOsB,GAChB,QAMN3C,EAHJC,EAAQ2D,EAAKgG,SAAS3J,EAAOgH,EAAMpC,MAI/BA,EAAMzB,eAAgB,GAItBjD,MAAMC,QAAQ8C,IAAWR,EAAaQ,EAAQP,GAC9CO,EAAOP,GAAQ1C,EAEfK,OAAO6B,eAAee,EAAQP,EAAM,OAAC1C,IAIrCmK,GAAenK,IAAUiE,EAAM3C,KAAKoB,GAAO,WAG9C,CAAA,GAAIyH,GAAetH,EAAG7C,EAAOiE,EAAM3C,KAAKoB,WAIpCzC,EAAYD,KAAWK,OAAOuJ,SAAS5J,IAC5CqC,EAAKrC,EAAOkK,GAGZC,GAAexG,EAAKwE,YACfA,SAASlE,EAAOvB,EAAM1C,WAInCqC,EAAK0H,EAAMG,GACJH,GC3RftJ,IAAM2J,EAAQ,IAAI9B,EAqBLG,EAAU2B,EAAM3B,QAQhBa,EAAgBc,EAAMd,cAAcZ,KAAK0B,GAQzC5B,EAAgB4B,EAAM5B,cAAcE,KAAK0B,GAOzC5C,EAAe4C,EAAM5C,aAAakB,KAAK0B,GAMvCjB,EAAciB,EAAMjB,YAAYT,KAAK0B,GAUrCf,EAAce,EAAMf,YAAYX,KAAK0B,qINrC3C,SAAkBpK,MACjBA,GAASA,EAAMF,UACRE,EAAMF,GAAawB"}